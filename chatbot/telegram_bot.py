# import logging
# import requests
# from telegram import Update
# from telegram.ext import (
#     Application,
#     CommandHandler,
#     MessageHandler,
#     filters,
#     ContextTypes,
# )
# from telegram.constants import ParseMode
# from datetime import datetime

# # Configure logging
# logging.basicConfig(
#     format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
#     level=logging.INFO,
# )
# logger = logging.getLogger(__name__)

# # FastAPI server URL
# API_URL = "http://localhost:8000/batch-quality-assessment/"
# BOT_TOKEN = "7852032398:AAGFoTXNtWBs-rQQQlUIfdIMPoBTcQkofaQ"

# async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
#     """Handle the /start command with Russian message."""
#     await update.message.reply_text(
#         "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –±–æ—Ç –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤! –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≥—Ä—É–∑–∏—Ç–µ –æ–¥–∏–Ω –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø–∞—Å–ø–æ—Ä—Ç, –º–∏–≥—Ä–∞—Ü–∏–æ–Ω–Ω–∞—è –∫–∞—Ä—Ç–∞) –≤ –≤–∏–¥–µ –≤—ã—Å–æ–∫–æ–∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —Å–∫–∞–Ω–∞ –∏–ª–∏ PDF."
#     )

# async def handle_document(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
#     """Handle document uploads (PDFs, images) and send to the FastAPI batch quality assessment endpoint."""
#     documents = []
    
#     if update.message.document:
#         documents = [update.message.document]
#     elif update.message.photo:
#         documents = [update.message.photo[-1]]
#     else:
#         await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≥—Ä—É–∑–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π –¥–æ–∫—É–º–µ–Ω—Ç (PDF –∏–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ).")
#         return

#     files = []
#     for doc in documents:
#         try:
#             file = await doc.get_file()
#             if update.message.document:
#                 file_name = doc.file_name or f"document_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
#                 mime_type = doc.mime_type or "application/octet-stream"
#             else:
#                 file_name = f"photo_{datetime.now().strftime('%Y%m%d_%H%M%S')}.jpg"
#                 mime_type = "image/jpeg"

#             file_bytes = await file.download_as_bytearray()
#             files.append(("files", (file_name, file_bytes, mime_type)))
#             logger.info(f"Received file: {file_name} from user {update.message.from_user.id}")
#         except Exception as e:
#             logger.error(f"Error processing file: {str(e)}")
#             await update.message.reply_text(
#                 f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
#             )
#             return

#     try:
#         response = requests.post(API_URL, files=files, timeout=120)
#         if response.status_code == 200:
#             results = response.json()
#             messages = ["üìÑ –î–æ–∫—É–º–µ–Ω—Ç—ã –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã:"]

#             doc_counter = 1
#             for result in results:
#                 filename = result["filename"]
#                 if result["error"]:
#                     messages.append(
#                         f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–∞ '{filename}': {result['error']}."
#                     )
#                     continue

#                 doc_results = result.get("result", [])
#                 if not doc_results:
#                     messages.append(
#                         f"‚ö†Ô∏è –í —Ñ–∞–π–ª–µ '{filename}' –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –¥–æ–∫—É–º–µ–Ω—Ç—ã. –ó–∞–≥—Ä—É–∑–∏—Ç–µ –≤—ã—Å–æ–∫–æ–∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —Å–∫–∞–Ω."
#                     )
#                     continue

#                 for doc_result in doc_results:
#                     doc_type = doc_result.get("doc_type", "unknown")
#                     quality_category = doc_result.get("quality_category", "unknown")

#                     doc_type_ru = {
#                         "passport": "–ü–∞—Å–ø–æ—Ä—Ç",
#                         "registration": "–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è",
#                         "children": "–î–µ—Ç—Å–∫–∏–π –¥–æ–∫—É–º–µ–Ω—Ç",
#                         "inn": "–ò–ù–ù",
#                         "snils": "–°–ù–ò–õ–°",
#                         "migration": "–ú–∏–≥—Ä–∞—Ü–∏–æ–Ω–Ω–∞—è –∫–∞—Ä—Ç–∞",
#                         "unknown": "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –¥–æ–∫—É–º–µ–Ω—Ç"
#                     }.get(doc_type.lower(), doc_type)

#                     if quality_category.lower() == "failed":
#                         messages.append(
#                             f"‚ö†Ô∏è –î–æ–∫—É–º–µ–Ω—Ç {doc_counter} ({doc_type_ru}) –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω. –ó–∞–≥—Ä—É–∑–∏—Ç–µ –≤—ã—Å–æ–∫–æ–∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —Å–∫–∞–Ω."
#                         )
#                     else:
#                         messages.append(
#                             f"‚úÖ –î–æ–∫—É–º–µ–Ω—Ç {doc_counter} ({doc_type_ru}) —É—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω."
#                         )
#                     doc_counter += 1

#             if len(messages) == 1:  # Only header, no documents
#                 messages.append("‚ö†Ô∏è –î–æ–∫—É–º–µ–Ω—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã. –ó–∞–≥—Ä—É–∑–∏—Ç–µ –≤—ã—Å–æ–∫–æ–∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —Å–∫–∞–Ω.")
#             await update.message.reply_text("\n".join(messages), parse_mode=ParseMode.MARKDOWN)
#         else:
#             logger.error(f"API error: {response.status_code} - {response.text}")
#             await update.message.reply_text(
#                 "–ò–∑–≤–∏–Ω–∏—Ç–µ, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–∏—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –ø–æ–∑–∂–µ."
#             )

#     except Exception as e:
#         logger.error(f"Error processing documents: {str(e)}", exc_info=True)
#         await update.message.reply_text(
#             "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–∏—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
#         )

# async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
#     """Log errors caused by updates."""
#     logger.error(f"Update {update} caused error {context.error}")

# def main() -> None:
#     """Run the bot."""
#     application = Application.builder().token(BOT_TOKEN).build()

#     application.add_handler(CommandHandler("start", start))
#     application.add_handler(MessageHandler(filters.Document.ALL | filters.PHOTO, handle_document))
#     application.add_error_handler(error_handler)

#     logger.info("Starting Telegram bot...")
#     application.run_polling(allowed_updates=Update.ALL_TYPES)

# if __name__ == "__main__":
#     main()


# import logging
# import requests
# from telegram import Update
# from telegram.ext import (
#     Application,
#     CommandHandler,
#     MessageHandler,
#     filters,
#     ContextTypes,
# )
# from telegram.constants import ParseMode
# from datetime import datetime

# logging.basicConfig(
#     format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
#     level=logging.INFO,
# )
# logger = logging.getLogger(__name__)

# API_URL = "http://localhost:8000/batch-quality-assessment/"
# BOT_TOKEN = "7852032398:AAGFoTXNtWBs-rQQQlUIfdIMPoBTcQkofaQ"

# async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
#     """Handle the /start command with Russian message."""
#     await update.message.reply_text(
#         "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –±–æ—Ç –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤! –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≥—Ä—É–∑–∏—Ç–µ –æ–¥–∏–Ω –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø–∞—Å–ø–æ—Ä—Ç, –º–∏–≥—Ä–∞—Ü–∏–æ–Ω–Ω–∞—è –∫–∞—Ä—Ç–∞) –≤ –≤–∏–¥–µ –≤—ã—Å–æ–∫–æ–∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —Å–∫–∞–Ω–∞ –∏–ª–∏ PDF."
#     )

# async def handle_document(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
#     """Handle document uploads (PDFs, images) and send to the FastAPI batch quality assessment endpoint."""
#     documents = []
    
#     if update.message.document:
#         documents = [update.message.document]
#     elif update.message.photo:
#         documents = [update.message.photo[-1]]
#     else:
#         await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≥—Ä—É–∑–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π –¥–æ–∫—É–º–µ–Ω—Ç (PDF –∏–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ).")
#         return

#     files = []
#     for doc in documents:
#         try:
#             file = await doc.get_file()
#             if update.message.document:
#                 file_name = doc.file_name or f"document_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
#                 mime_type = doc.mime_type or "application/octet-stream"
#             else:
#                 file_name = f"photo_{datetime.now().strftime('%Y%m%d_%H%M%S')}.jpg"
#                 mime_type = "image/jpeg"

#             file_bytes = await file.download_as_bytearray()
#             files.append(("files", (file_name, file_bytes, mime_type)))
#             logger.info(f"Received file: {file_name} from user {update.message.from_user.id}")
#         except Exception as e:
#             logger.error(f"Error processing file: {str(e)}")
#             await update.message.reply_text(
#                 f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
#             )
#             return

#     try:
#         response = requests.post(API_URL, files=files, timeout=120)
#         if response.status_code == 200:
#             results = response.json()
#             messages = ["üìÑ –î–æ–∫—É–º–µ–Ω—Ç—ã –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã:"]

#             doc_counter = 1
#             reupload_prompt = False
#             for result in results:
#                 filename = result["filename"]
#                 if result["error"]:
#                     messages.append(
#                         f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–∞ '{filename}': {result['error']}."
#                     )
#                     reupload_prompt = True
#                     continue

#                 doc_results = result.get("result", [])
#                 if not doc_results:
#                     messages.append(
#                         f"‚ö†Ô∏è –í —Ñ–∞–π–ª–µ '{filename}' –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –¥–æ–∫—É–º–µ–Ω—Ç—ã. –ó–∞–≥—Ä—É–∑–∏—Ç–µ –≤—ã—Å–æ–∫–æ–∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —Å–∫–∞–Ω."
#                     )
#                     reupload_prompt = True
#                     continue

#                 if result.get("reupload_required", False):
#                     reupload_prompt = True

#                 for doc_result in doc_results:
#                     doc_type = doc_result.get("doc_type", "unknown")
#                     quality_category = doc_result.get("quality_category", "unknown")

#                     doc_type_ru = {
#                         "passport": "–ü–∞—Å–ø–æ—Ä—Ç",
#                         "registration": "–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è",
#                         "children": "–î–µ—Ç—Å–∫–∏–π –¥–æ–∫—É–º–µ–Ω—Ç",
#                         "inn": "–ò–ù–ù",
#                         "snils": "–°–ù–ò–õ–°",
#                         "migration": "–ú–∏–≥—Ä–∞—Ü–∏–æ–Ω–Ω–∞—è –∫–∞—Ä—Ç–∞",
#                         "unknown": "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –¥–æ–∫—É–º–µ–Ω—Ç"
#                     }.get(doc_type.lower(), doc_type)

#                     if quality_category.lower() in ["failed", "poor"]:
#                         messages.append(
#                             f"‚ö†Ô∏è –î–æ–∫—É–º–µ–Ω—Ç {doc_counter} ({doc_type_ru}) –∏–º–µ–µ—Ç –Ω–∏–∑–∫–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ ({quality_category}). –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≥—Ä—É–∑–∏—Ç–µ –≤—ã—Å–æ–∫–æ–∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —Å–∫–∞–Ω."
#                         )
#                     else:
#                         messages.append(
#                             f"‚úÖ –î–æ–∫—É–º–µ–Ω—Ç {doc_counter} ({doc_type_ru}) —É—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω, –∫–∞—á–µ—Å—Ç–≤–æ: {quality_category}."
#                         )
#                     doc_counter += 1

#             if reupload_prompt:
#                 messages.append("üìé –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≥—Ä—É–∑–∏—Ç–µ –¥–æ–∫—É–º–µ–Ω—Ç—ã —Å –±–æ–ª–µ–µ –≤—ã—Å–æ–∫–∏–º –∫–∞—á–µ—Å—Ç–≤–æ–º –¥–ª—è —Ç–æ—á–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏.")

#             if len(messages) == 1:  # Only header, no documents
#                 messages.append("‚ö†Ô∏è –î–æ–∫—É–º–µ–Ω—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã. –ó–∞–≥—Ä—É–∑–∏—Ç–µ –≤—ã—Å–æ–∫–æ–∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —Å–∫–∞–Ω.")
#             await update.message.reply_text("\n".join(messages), parse_mode=ParseMode.MARKDOWN)
#         else:
#             logger.error(f"API error: {response.status_code} - {response.text}")
#             await update.message.reply_text(
#                 "–ò–∑–≤–∏–Ω–∏—Ç–µ, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–∏—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –ø–æ–∑–∂–µ."
#             )

#     except Exception as e:
#         logger.error(f"Error processing documents: {str(e)}", exc_info=True)
#         await update.message.reply_text(
#             "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–∏—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
#         )

# async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
#     """Log errors caused by updates."""
#     logger.error(f"Update {update} caused error {context.error}")

# def main() -> None:
#     """Run the bot."""
#     application = Application.builder().token(BOT_TOKEN).build()

#     application.add_handler(CommandHandler("start", start))
#     application.add_handler(MessageHandler(filters.Document.ALL | filters.PHOTO, handle_document))
#     application.add_error_handler(error_handler)

#     logger.info("Starting Telegram bot...")
#     application.run_polling(allowed_updates=Update.ALL_TYPES)

# if __name__ == "__main__":
#     main()


# import logging
# import requests
# from telegram import Update
# from telegram.ext import (
#     Application,
#     CommandHandler,
#     MessageHandler,
#     filters,
#     ContextTypes,
# )
# from telegram.constants import ParseMode

# # Configure logging
# logging.basicConfig(
#     format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
#     level=logging.INFO,
# )
# logger = logging.getLogger(__name__)

# # FastAPI server URL
# API_URL = "http://localhost:8000/batch-quality-assessment/"
# BOT_TOKEN = "7852032398:AAGFoTXNtWBs-rQQQlUIfdIMPoBTcQkofaQ"

# async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
#     """Handle the /start command with Russian message."""
#     await update.message.reply_text(
#         "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –±–æ—Ç –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤! –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≥—Ä—É–∑–∏—Ç–µ –æ–¥–∏–Ω –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø–∞—Å–ø–æ—Ä—Ç, —Ä–µ–∑—é–º–µ)."
#     )

# async def handle_document(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
#     """Handle document uploads (single or multiple) and send to the FastAPI batch quality assessment endpoint."""
#     documents = []
    
#     if update.message.document:
#         documents = [update.message.document]
#     elif update.message.photo:
#         documents = [update.message.photo[-1]]
#     else:
#         await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≥—Ä—É–∑–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π –¥–æ–∫—É–º–µ–Ω—Ç –∏–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.")
#         return

#     files = []
#     for doc in documents:
#         try:
#             file = await doc.get_file()
#             if update.message.document:
#                 file_name = doc.file_name or f"document_{file.file_id}"
#                 mime_type = doc.mime_type or "application/octet-stream"
#             else:
#                 file_name = f"photo_{file.file_id}.jpg"
#                 mime_type = "image/jpeg"

#             file_bytes = await file.download_as_bytearray()
#             files.append(("files", (file_name, file_bytes, mime_type)))
#             logger.info(f"Received file: {file_name} from user {update.message.from_user.id}")
#         except Exception as e:
#             logger.error(f"Error processing file: {str(e)}")
#             await update.message.reply_text(
#                 f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
#             )
#             return

#     try:
#         response = requests.post(API_URL, files=files, timeout=60)
#         if response.status_code == 200:
#             results = response.json()
#             messages = []
#             for result in results:
#                 filename = result["filename"]
#                 if result["error"]:
#                     messages.append(
#                         f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–∞ '{filename}': {result['error']}. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
#                     )
#                     continue

#                 doc_results = result["result"]
#                 if not doc_results:
#                     messages.append(
#                         f"‚ö†Ô∏è –§–∞–π–ª '{filename}' –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤."
#                     )
#                     continue

#                 for idx, doc_result in enumerate(doc_results, 1):
#                     doc_type = doc_result["doc_type"]
#                     quality_category = doc_result["quality_category"]

#                     doc_type_ru = {
#                         "passport": "–ü–∞—Å–ø–æ—Ä—Ç",
#                         "resume": "–†–µ–∑—é–º–µ",
#                         "id_card": "–£–¥–æ—Å—Ç–æ–≤–µ—Ä–µ–Ω–∏–µ –ª–∏—á–Ω–æ—Å—Ç–∏",
#                         "unknown": f"{filename} (–î–æ–∫—É–º–µ–Ω—Ç {idx})"
#                     }.get(doc_type.lower(), doc_type)

#                     if quality_category.lower() == "failed":
#                         messages.append(
#                             f"‚ö†Ô∏è –î–æ–∫—É–º–µ–Ω—Ç {idx} ('{doc_type_ru}') –≤ —Ñ–∞–π–ª–µ '{filename}' –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≥—Ä—É–∑–∏—Ç–µ –±–æ–ª–µ–µ —á–µ—Ç–∫—É—é –≤–µ—Ä—Å–∏—é."
#                         )
#                     elif quality_category.lower() in ["excellent", "moderate"]:
#                         messages.append(
#                             f"‚úÖ –î–æ–∫—É–º–µ–Ω—Ç {idx} ('{doc_type_ru}') –≤ —Ñ–∞–π–ª–µ '{filename}' —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω."
#                         )
#                     else:
#                         messages.append(
#                             f"‚ö†Ô∏è –î–æ–∫—É–º–µ–Ω—Ç {idx} ('{doc_type_ru}') –≤ —Ñ–∞–π–ª–µ '{filename}' –∏–º–µ–µ—Ç –Ω–∏–∑–∫–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≥—Ä—É–∑–∏—Ç–µ –±–æ–ª–µ–µ —á–µ—Ç–∫—É—é –≤–µ—Ä—Å–∏—é."
#                         )

#             await update.message.reply_text("\n".join(messages), parse_mode=ParseMode.MARKDOWN)
#         else:
#             logger.error(f"API error: {response.status_code} - {response.text}")
#             await update.message.reply_text(
#                 "–ò–∑–≤–∏–Ω–∏—Ç–µ, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–∏—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –ø–æ–∑–∂–µ."
#             )

#     except Exception as e:
#         logger.error(f"Error processing documents: {str(e)}", exc_info=True)
#         await update.message.reply_text(
#             "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–∏—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
#         )

# async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
#     """Log errors caused by updates."""
#     logger.error(f"Update {update} caused error {context.error}")

# def main() -> None:
#     """Run the bot."""
#     application = Application.builder().token(BOT_TOKEN).build()

#     application.add_handler(CommandHandler("start", start))
#     application.add_handler(MessageHandler(filters.Document.ALL | filters.PHOTO, handle_document))
#     application.add_error_handler(error_handler)

#     logger.info("Starting Telegram bot...")
#     application.run_polling(allowed_updates=Update.ALL_TYPES)

# if __name__ == "__main__":
#     main()



# import logging
# import requests
# from telegram import Update
# from telegram.ext import (
#     Application,
#     CommandHandler,
#     MessageHandler,
#     filters,
#     ContextTypes,
# )
# from telegram.constants import ParseMode
# from datetime import datetime

# # Configure logging
# logging.basicConfig(
#     format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
#     level=logging.INFO,
# )
# logger = logging.getLogger(__name__)

# # FastAPI server URL
# API_URL = "http://localhost:8000/batch-quality-assessment/"
# BOT_TOKEN = "7852032398:AAGFoTXNtWBs-rQQQlUIfdIMPoBTcQkofaQ"

# async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
#     """Handle the /start command with Russian message."""
#     await update.message.reply_text(
#         "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –±–æ—Ç –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤! –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≥—Ä—É–∑–∏—Ç–µ –æ–¥–∏–Ω –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø–∞—Å–ø–æ—Ä—Ç, —Ä–µ–∑—é–º–µ) –≤ –≤–∏–¥–µ –≤—ã—Å–æ–∫–æ–∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —Å–∫–∞–Ω–∞."
#     )

# async def handle_document(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
#     """Handle document uploads (single or multiple) and send to the FastAPI batch quality assessment endpoint."""
#     documents = []
    
#     if update.message.document:
#         documents = [update.message.document]
#     elif update.message.photo:
#         documents = [update.message.photo[-1]]
#     else:
#         await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≥—Ä—É–∑–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π –¥–æ–∫—É–º–µ–Ω—Ç –∏–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.")
#         return

#     files = []
#     for doc in documents:
#         try:
#             file = await doc.get_file()
#             if update.message.document:
#                 file_name = doc.file_name or f"document_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
#                 mime_type = doc.mime_type or "application/octet-stream"
#             else:
#                 file_name = f"photo_{datetime.now().strftime('%Y%m%d_%H%M%S')}.jpg"
#                 mime_type = "image/jpeg"

#             file_bytes = await file.download_as_bytearray()
#             files.append(("files", (file_name, file_bytes, mime_type)))
#             logger.info(f"Received file: {file_name} from user {update.message.from_user.id}")
#         except Exception as e:
#             logger.error(f"Error processing file: {str(e)}")
#             await update.message.reply_text(
#                 f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
#             )
#             return

#     try:
#         response = requests.post(API_URL, files=files, timeout=60)
#         if response.status_code == 200:
#             results = response.json()
#             messages = []
#             for result in results:
#                 filename = result["filename"]
#                 if result["error"]:
#                     messages.append(
#                         f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–∞ '{filename}': {result['error']}."
#                     )
#                     continue

#                 doc_results = result.get("result", [])
#                 if not doc_results:
#                     messages.append(
#                         f"‚ö†Ô∏è –í —Ñ–∞–π–ª–µ '{filename}' –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –¥–æ–∫—É–º–µ–Ω—Ç—ã. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≥—Ä—É–∑–∏—Ç–µ –≤—ã—Å–æ–∫–æ–∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —Å–∫–∞–Ω –¥–æ–∫—É–º–µ–Ω—Ç–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Å –ø–æ–º–æ—â—å—é —Å–∫–∞–Ω–µ—Ä–∞, –∞ –Ω–µ –∫–∞–º–µ—Ä—ã —Ç–µ–ª–µ—Ñ–æ–Ω–∞)."
#                     )
#                     continue

#                 for idx, doc_result in enumerate(doc_results, 1):
#                     doc_type = doc_result.get("doc_type", "unknown")
#                     quality_category = doc_result.get("quality_category", "unknown")

#                     doc_type_ru = {
#                         "passport": "–ü–∞—Å–ø–æ—Ä—Ç",
#                         "resume": "–†–µ–∑—é–º–µ",
#                         "id_card": "–£–¥–æ—Å—Ç–æ–≤–µ—Ä–µ–Ω–∏–µ –ª–∏—á–Ω–æ—Å—Ç–∏",
#                         "migration": "–ú–∏–≥—Ä–∞—Ü–∏–æ–Ω–Ω–∞—è –∫–∞—Ä—Ç–∞",
#                         "unknown": f"–î–æ–∫—É–º–µ–Ω—Ç {idx}"
#                     }.get(doc_type.lower(), doc_type)

#                     if quality_category.lower() == "failed":
#                         messages.append(
#                             f"‚ö†Ô∏è –î–æ–∫—É–º–µ–Ω—Ç {idx} ({doc_type_ru}) –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω. –ó–∞–≥—Ä—É–∑–∏—Ç–µ –≤—ã—Å–æ–∫–æ–∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —Å–∫–∞–Ω –¥–æ–∫—É–º–µ–Ω—Ç–∞."
#                         )
#                     elif quality_category.lower() in ["excellent", "moderate"]:
#                         messages.append(
#                             f"‚úÖ –î–æ–∫—É–º–µ–Ω—Ç {idx} ({doc_type_ru}) —É—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω."
#                         )
#                     else:
#                         messages.append(
#                             f"‚ö†Ô∏è –î–æ–∫—É–º–µ–Ω—Ç {idx} ({doc_type_ru}) –∏–º–µ–µ—Ç –Ω–∏–∑–∫–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ. –ó–∞–≥—Ä—É–∑–∏—Ç–µ –≤—ã—Å–æ–∫–æ–∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —Å–∫–∞–Ω –¥–æ–∫—É–º–µ–Ω—Ç–∞."
#                         )

#             await update.message.reply_text("\n".join(messages), parse_mode=ParseMode.MARKDOWN)
#         else:
#             logger.error(f"API error: {response.status_code} - {response.text}")
#             await update.message.reply_text(
#                 "–ò–∑–≤–∏–Ω–∏—Ç–µ, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–∏—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –ø–æ–∑–∂–µ."
#             )

#     except Exception as e:
#         logger.error(f"Error processing documents: {str(e)}", exc_info=True)
#         await update.message.reply_text(
#             "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–∏—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
#         )

# async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
#     """Log errors caused by updates."""
#     logger.error(f"Update {update} caused error {context.error}")

# def main() -> None:
#     """Run the bot."""
#     application = Application.builder().token(BOT_TOKEN).build()

#     application.add_handler(CommandHandler("start", start))
#     application.add_handler(MessageHandler(filters.Document.ALL | filters.PHOTO, handle_document))
#     application.add_error_handler(error_handler)

#     logger.info("Starting Telegram bot...")
#     application.run_polling(allowed_updates=Update.ALL_TYPES)

# if __name__ == "__main__":
#     main()
import logging
import requests
from telegram import Update
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes,
)
from telegram.constants import ParseMode
from datetime import datetime

# Configure logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO,
)
logger = logging.getLogger(__name__)

# FastAPI server URL
API_URL = "http://localhost:8000/batch-quality-assessment/"
BOT_TOKEN = "7852032398:AAGFoTXNtWBs-rQQQlUIfdIMPoBTcQkofaQ"

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle the /start command with Russian message."""
    await update.message.reply_text(
        "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –±–æ—Ç –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤! –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≥—Ä—É–∑–∏—Ç–µ –æ–¥–∏–Ω –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø–∞—Å–ø–æ—Ä—Ç, —Ä–µ–∑—é–º–µ) –≤ –≤–∏–¥–µ –≤—ã—Å–æ–∫–æ–∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —Å–∫–∞–Ω–∞ –∏–ª–∏ PDF."
    )

async def handle_document(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle document uploads (PDFs, images) and send to the FastAPI batch quality assessment endpoint."""
    documents = []
    
    if update.message.document:
        documents = [update.message.document]
    elif update.message.photo:
        documents = [update.message.photo[-1]]
    else:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≥—Ä—É–∑–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π –¥–æ–∫—É–º–µ–Ω—Ç (PDF –∏–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ).")
        return

    files = []
    for doc in documents:
        try:
            file = await doc.get_file()
            if update.message.document:
                file_name = doc.file_name or f"document_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
                mime_type = doc.mime_type or "application/octet-stream"
            else:
                file_name = f"photo_{datetime.now().strftime('%Y%m%d_%H%M%S')}.jpg"
                mime_type = "image/jpeg"

            file_bytes = await file.download_as_bytearray()
            files.append(("files", (file_name, file_bytes, mime_type)))
            logger.info(f"Received file: {file_name} from user {update.message.from_user.id}")
        except Exception as e:
            logger.error(f"Error processing file: {str(e)}")
            await update.message.reply_text(
                f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
            )
            return

    try:
        response = requests.post(API_URL, files=files, timeout=120)
        if response.status_code == 200:
            results = response.json()
            messages = []
            for result in results:
                filename = result["filename"]
                if result["error"]:
                    messages.append(
                        f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–∞ '{filename}': {result['error']}."
                    )
                    continue

                doc_results = result.get("result", [])
                # Extract page number for PDFs
                page_info = ""
                if "_page" in filename:
                    page_num = filename.split("_page")[1].split(".")[0]
                    page_info = f" (–°—Ç—Ä–∞–Ω–∏—Ü–∞ {page_num})"

                if not doc_results:
                    messages.append(
                        f"‚ö†Ô∏è –í —Ñ–∞–π–ª–µ '{filename}'{page_info} –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –¥–æ–∫—É–º–µ–Ω—Ç—ã. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≥—Ä—É–∑–∏—Ç–µ –≤—ã—Å–æ–∫–æ–∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —Å–∫–∞–Ω –¥–æ–∫—É–º–µ–Ω—Ç–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Å –ø–æ–º–æ—â—å—é —Å–∫–∞–Ω–µ—Ä–∞, –∞ –Ω–µ –∫–∞–º–µ—Ä—ã —Ç–µ–ª–µ—Ñ–æ–Ω–∞)."
                    )
                    continue

                for idx, doc_result in enumerate(doc_results, 1):
                    doc_type = doc_result.get("doc_type", "unknown")
                    quality_category = doc_result.get("quality_category", "unknown")

                    doc_type_ru = {
                        "passport": "–ü–∞—Å–ø–æ—Ä—Ç",
                        "resume": "–†–µ–∑—é–º–µ",
                        "id_card": "–£–¥–æ—Å—Ç–æ–≤–µ—Ä–µ–Ω–∏–µ –ª–∏—á–Ω–æ—Å—Ç–∏",
                        "migration": "–ú–∏–≥—Ä–∞—Ü–∏–æ–Ω–Ω–∞—è –∫–∞—Ä—Ç–∞",
                        "unknown": f"–î–æ–∫—É–º–µ–Ω—Ç {idx}"
                    }.get(doc_type.lower(), doc_type)

                    if quality_category.lower() == "failed":
                        messages.append(
                            f"‚ö†Ô∏è –î–æ–∫—É–º–µ–Ω—Ç {idx} ({doc_type_ru}){page_info} –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω. –ó–∞–≥—Ä—É–∑–∏—Ç–µ –≤—ã—Å–æ–∫–æ–∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —Å–∫–∞–Ω –¥–æ–∫—É–º–µ–Ω—Ç–∞."
                        )
                    elif quality_category.lower() in ["excellent", "moderate"]:
                        messages.append(
                            f"‚úÖ –î–æ–∫—É–º–µ–Ω—Ç {idx} ({doc_type_ru}){page_info} —É—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω."
                        )
                    else:
                        messages.append(
                            f"‚ö†Ô∏è –î–æ–∫—É–º–µ–Ω—Ç {idx} ({doc_type_ru}){page_info} –∏–º–µ–µ—Ç –Ω–∏–∑–∫–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ. –ó–∞–≥—Ä—É–∑–∏—Ç–µ –≤—ã—Å–æ–∫–æ–∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —Å–∫–∞–Ω –¥–æ–∫—É–º–µ–Ω—Ç–∞."
                        )

            await update.message.reply_text("\n".join(messages), parse_mode=ParseMode.MARKDOWN)
        else:
            logger.error(f"API error: {response.status_code} - {response.text}")
            await update.message.reply_text(
                "–ò–∑–≤–∏–Ω–∏—Ç–µ, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–∏—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –ø–æ–∑–∂–µ."
            )

    except Exception as e:
        logger.error(f"Error processing documents: {str(e)}", exc_info=True)
        await update.message.reply_text(
            "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–∏—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
        )

async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Log errors caused by updates."""
    logger.error(f"Update {update} caused error {context.error}")

def main() -> None:
    """Run the bot."""
    application = Application.builder().token(BOT_TOKEN).build()

    application.add_handler(CommandHandler("start", start))
    application.add_handler(MessageHandler(filters.Document.ALL | filters.PHOTO, handle_document))
    application.add_error_handler(error_handler)

    logger.info("Starting Telegram bot...")
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    main()